{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"14085029651750006277","abi":{"parameters":[{"name":"paths","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"root","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"11714454086230212499":{"error_kind":"string","string":"the roots don't match"},"14370616181497445055":{"error_kind":"string","string":"evil hash detected"}}},"bytecode":"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","debug_symbols":"pZfdbuIwFITfJddc+Ng+/tlXWa0qStMKKQoohZVWVd99EzzjQiVHFVz5gDNf7eMZl3x0L/3z+e1pP74e3rtfvz+652k/DPu3p+Gw2572h3H+9uNz0/Hj02nq+/mr7mp+Vh23Uz+eul/jeRg23d/tcL489H7cjpfxtJ3mWbPp+vFlHmfg637ol+pz86U2bak3CrEXqXK91Utbn4OFPqfwpbc3erv298VzAcbeRQiaSAg5tQi+TZDEBkrWVg+0rXeReu981dtbfWjrrRMHgHVXPfhGiCs7kBS4BWvyPWuIhudgo8QWIa+swTnuQtzc/AZBzJqZSMix2YaVg/AS6kG4u5rgTW2CNo9yOa1mF2KO7EKS5iZkzY6mrkJMynetIn+dRfbNVazmMtRUmWRaqVrbx49Oc20J0dZcRd8Mtqx4MkYuIV7fTj9fQebt5pPT5uUkD94t1j54uVj3sKmtf9jUVh81gz6citVt/CwVa6dpYq6LyE1DrP2/rbvw2vTDil4d9fpN/2f+tN3tp5tfGJ2ZVzp3Vcpgy+DK4JetbzotQyhDLENa3LLpMuSmfCuC0WJ0GIESsCQUuUSMCZxc5i14FjwLngXPgme16C14NmIfCfPgOfAceA48B57zRe/AcwGNwG4deA48D54Hz4PnXdF78Lyik2ieB8+D58FT8BQ8tUWv4KkvHEX/FDwFT8FT8AJ4QYo+gBdwsgH9Czxb8AJ4AbwAXjRFH8GLMEpE/yJ4EbxIs4AXwYu56BN4Cb5L6F8CL4GXwEvgJboP9kvgZdg4o38ZvAxeBi+Dl8HL8F+mnaufaWhDRxta2tDThqY2dLWhrQ19bWhsk5mQGhWSa1hqWmpcBH6UGhiBw0USnyGZoRFbU0gycyMWxhQmRyysLjbyGZKZHmF8hPkRVwMOhwojJJcM5aWYye7yzEx2shSJRUaxBKkUwsKycCw8C2URWJDsSfYkK8lKspKsJCvJSrKSrCQryUpyIDmQHEgOJAeSA8mB5EByuJA/l7t82m+fhx6vfK/ncXf1Bnj6d+QM3xGP02HXv5ynfrnLL3Pz7f4f","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"20":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"50":{"source":"use trees::merkle::MerkleTree;\nuse std::hash::poseidon2::Poseidon2::hash;\nuse trees::types::{Modifier, MembershipProver, MT_Creator};\n\nfn hasher(leaves: [Field; 2]) -> Field {\n    hash(leaves, 2)\n}\n\nfn main(paths: [Field; 16], root: pub Field) {\n    let mut mt = MerkleTree::new(hasher);\n    let bad_hashes = [0x1376c0e4a9906befb46125f90f4d972a5e4682d2e605e0be74b2ead27a59bac3];\n    // add at index 0\n    mt.add(0x0, 0, paths);\n    assert( root == mt.root, \"the roots don't match\");\n    for i in 0 .. paths.len() {\n        assert(paths[i] != bad_hashes[0], \"evil hash detected\");\n    }\n    // prove it is in the tree (kinda redundant isn't it?)\n    // mt.membership(0x0, 0, paths);\n}\n\n//MANUAL ATTEMPT !\n// let mut skip = false;\n\n    // let mut res: Field = hash([paths[0], paths[1]], 2);\n    \n    // let mut p = paths;\n    // for _ in 0..4 {\n    //     let mut new_path: [Field] = [];\n    //     for i in 0..p.len() - 1 {\n    //         if skip {\n    //             skip = false;\n    //         } else {\n    //             assert((bad_hashes[0] != paths[i]) & (bad_hashes[0] != paths[i + 1]));\n    //             let interm = hash([paths[i], paths[i + 1]], 2);\n    //             new_path = new_path.push_back(interm);\n    //             skip = true;\n    //         }\n    //     }\n    //     p = new_path.as_array();\n    // }\n","path":"/home/user/code/projects/anticheatz/merkleProof/src/main.nr"},"52":{"source":"pub use crate::types::{Calculator, MembershipProver, Modifier, MT_Creator};\n\npub struct MerkleTree<T> {\n    pub root: T,\n    pub hasher: fn([T; 2]) -> T,\n}\n\nimpl<T> MT_Creator<T> for MerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn default(root: T, hasher: fn([T; 2]) -> T) -> Self {\n        Self { root, hasher }\n    }\n\n    fn from(root: T, hasher: fn([T; 2]) -> T) -> Self {\n        Self::default(root, hasher)\n    }\n\n    fn new(hasher: fn([T; 2]) -> T) -> Self {\n        Self::from(T::default(), hasher)\n    }\n}\n\nimpl<T> MembershipProver<T, T> for MerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn membership<let N: u32>(self, leaf: T, indexes: Field, hash_path: [T; N]) {\n        let root = self.calculate_root(leaf, indexes, hash_path);\n        assert(self.root == root);\n    }\n}\n\nimpl<T> Modifier<T, T> for MerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn add<let N: u32>(&mut self, leaf: T, indexes: Field, hash_path: [T; N]) {\n        let (old, new) = self.calculate_two_roots(leaf, indexes, hash_path);\n        // println(new);\n        // println(old);\n        assert(old == self.root);\n        self.root = new;\n    }\n\n    fn delete<let N: u32>(&mut self, leaf: T, indexes: Field, hash_path: [T; N]) {\n        let (new, old) = self.calculate_two_roots(leaf, indexes, hash_path);\n        assert(old == self.root);\n        self.root = new;\n    }\n\n    fn update<let N: u32>(&mut self, leaf: T, old_leaf: T, indexes: Field, hash_path: [T; N]) {\n        let index_bits: [u1; N] = indexes.to_le_bits();\n\n        let mut old_parent = old_leaf;\n        let mut new_parent = leaf;\n\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            if index_bits[i] == 0 {\n                new_parent = (self.hasher)([new_parent, sibling]);\n                old_parent = (self.hasher)([old_parent, sibling]);\n            } else {\n                new_parent = (self.hasher)([sibling, new_parent]);\n                old_parent = (self.hasher)([sibling, old_parent]);\n            }\n        }\n        assert(old_parent == self.root);\n        self.root = new_parent;\n    }\n}\n\nimpl<T> Calculator<T, T> for MerkleTree<T>\nwhere\n    T: Eq + Default,\n{\n    fn calculate_root<let N: u32>(self, leaf: T, indexes: Field, hash_path: [T; N]) -> T {\n        let index_bits: [u1; N] = indexes.to_le_bits();\n        let mut node = leaf;\n        for i in 0..hash_path.len() {\n            let sibling = hash_path[i];\n            if index_bits[i] == 0 {\n                let left = node;\n                let right = sibling;\n                node = (self.hasher)([left, right]);\n            } else {\n                let left = sibling;\n                let right = node;\n                node = (self.hasher)([left, right]);\n            }\n        }\n        node\n    }\n\n    /*\n     * Calculates two roots for a given leaf entry based on the passed array of siblings: one root\n     * for if the leaf entry was included in the tree and one for if the leaf entry was not included\n     * in the tree. This is useful for efficiently proving the membership of leaf entries for a\n     * tree while simultaneously modifying the tree.\n     * @param entry The key and value of an entry [k, v]\n     * @param siblings Contains the siblings from bottom to top\n     * @returns Two root nodes: the first one doesn't include entry, the second does\n     */\n    fn calculate_two_roots<let N: u32>(self, leaf: T, indexes: Field, hash_path: [T; N]) -> (T, T) {\n        let index_bits: [u1; N] = indexes.to_be_bits();\n        \n        // root_with_leaf is a container for hashes to derive the root node for the tree that\n        // includes the entry\n        let mut root_with_leaf = leaf;\n        // root_without_leaf is a container for hashes to derive the root node for the tree that\n        // doesn't include the entry\n        let mut root_without_leaf = T::default();\n\n        // iterate over the levels of the tree from bottom to top\n        for i in 0..hash_path.len() {\n            if i == 0 {\n                root_without_leaf = hash_path[i];\n            }\n            let sibling = hash_path[i];\n            // After the first sibling is found, the processes are started to calculate the two root nodes.\n            // The calulcation of the root node that includes the entry is comparable to `calculate_root`.\n            // To calc the root node that doesn't include entry, the first sibling is put into the container\n            // and starting from each SUBSEQUENT iteration it is hashed with its sibling and the resulting hash\n            // again stored in the container until the root is reached\n            if index_bits[i] == 0 {\n                root_with_leaf = (self.hasher)([root_with_leaf, sibling]);\n                if (root_without_leaf != sibling) {\n                    root_without_leaf = (self.hasher)([root_without_leaf, sibling]);\n                }\n            } else {\n                root_with_leaf = (self.hasher)([sibling, root_with_leaf]);\n                if (root_without_leaf != sibling) {\n                    root_without_leaf = (self.hasher)([sibling, root_without_leaf]);\n                }\n            }\n        }\n        (root_without_leaf, root_with_leaf)\n    }\n}\n","path":"/home/user/code/projects/anticheatz/merkleProof/merkle-trees/src/merkle.nr"}},"names":["main"],"brillig_names":["directive_invert"]}